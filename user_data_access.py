# -*- coding: utf-8 -*-
"""User Data Access Module for Flet App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pFKoUvxknZE4NCNjhjZ3jVKqensOgY14
"""

import httpx
from typing import List, Dict, Optional

# Define the base URL for your FastAPI backend
# Make sure this matches where your FastAPI app is running (e.g., uvicorn main:app --reload)
BASE_API_URL = "<path of user logic"

class MentalHealthTrackerService:
    """
    A service class to handle all data access operations for the Community Mental Health Tracker.
    It communicates with the FastAPI backend.
    """

    def __init__(self, base_url: str = BASE_API_URL):
        """
        Initializes the service with the base URL of the FastAPI backend.
        """
        self.base_url = base_url
        self.client = httpx.AsyncClient() # Use AsyncClient for async operations

    async def close(self):
        """
        Closes the HTTP client session. Should be called when the application exits.
        """
        await self.client.aclose()

    async def create_user(self, user_id: str, username: str) -> Optional[Dict]:
        """
        Creates a new user in the backend.

        Args:
            user_id (str): A unique ID for the user (e.g., generated by Flet/client).
            username (str): The username for the new user.

        Returns:
            Optional[Dict]: The created user data if successful, None otherwise.
        """
        endpoint = f"{self.base_url}/users/"
        payload = {"id": user_id, "username": username}
        try:
            response = await self.client.post(endpoint, json=payload)
            response.raise_for_status() # Raises an exception for 4xx/5xx responses
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"Error creating user: {e.response.status_code} - {e.response.text}")
            return None
        except httpx.RequestError as e:
            print(f"Network error creating user: {e}")
            return None

    async def get_user(self, user_id: str) -> Optional[Dict]:
        """
        Retrieves user details from the backend.

        Args:
            user_id (str): The ID of the user to retrieve.

        Returns:
            Optional[Dict]: The user data if found, None otherwise.
        """
        endpoint = f"{self.base_url}/users/{user_id}"
        try:
            response = await self.client.get(endpoint)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                print(f"User with ID {user_id} not found.")
            else:
                print(f"Error getting user: {e.response.status_code} - {e.response.text}")
            return None
        except httpx.RequestError as e:
            print(f"Network error getting user: {e}")
            return None

    async def log_mood(self, user_id: str, mood_score: int) -> Optional[Dict]:
        """
        Logs a new mood entry for a specific user.

        Args:
            user_id (str): The ID of the user.
            mood_score (int): The mood score (1-5).

        Returns:
            Optional[Dict]: The logged mood entry data if successful, None otherwise.
        """
        endpoint = f"{self.base_url}/mood_entries/"
        payload = {"user_id": user_id, "mood_score": mood_score}
        try:
            response = await self.client.post(endpoint, json=payload)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"Error logging mood: {e.response.status_code} - {e.response.text}")
            return None
        except httpx.RequestError as e:
            print(f"Network error logging mood: {e}")
            return None

    async def get_mood_entries(self, user_id: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """
        Retrieves recent mood entries for a specific user.

        Args:
            user_id (str): The ID of the user.
            limit (int): Maximum number of entries to retrieve.
            offset (int): Number of entries to skip.

        Returns:
            List[Dict]: A list of mood entry dictionaries.
        """
        endpoint = f"{self.base_url}/mood_entries/{user_id}"
        params = {"limit": limit, "offset": offset}
        try:
            response = await self.client.get(endpoint, params=params)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"Error getting mood entries: {e.response.status_code} - {e.response.text}")
            return []
        except httpx.RequestError as e:
            print(f"Network error getting mood entries: {e}")
            return []

    async def save_journal_entry(self, user_id: str, entry_text: str) -> Optional[Dict]:
        """
        Saves a new journal entry for a specific user.

        Args:
            user_id (str): The ID of the user.
            entry_text (str): The content of the journal entry.

        Returns:
            Optional[Dict]: The saved journal entry data if successful, None otherwise.
        """
        endpoint = f"{self.base_url}/journal_entries/"
        payload = {"user_id": user_id, "entry_text": entry_text}
        try:
            response = await self.client.post(endpoint, json=payload)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"Error saving journal entry: {e.response.status_code} - {e.response.text}")
            return None
        except httpx.RequestError as e:
            print(f"Network error saving journal entry: {e}")
            return None

    async def get_journal_entries(self, user_id: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """
        Retrieves recent journal entries for a specific user.

        Args:
            user_id (str): The ID of the user.
            limit (int): Maximum number of entries to retrieve.
            offset (int): Number of entries to skip.

        Returns:
            List[Dict]: A list of journal entry dictionaries.
        """
        endpoint = f"{self.base_url}/journal_entries/{user_id}"
        params = {"limit": limit, "offset": offset}
        try:
            response = await self.client.get(endpoint, params=params)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"Error getting journal entries: {e.response.status_code} - {e.response.text}")
            return []
        except httpx.RequestError as e:
            print(f"Network error getting journal entries: {e}")
            return []

    async def get_insights(self, user_id: str) -> List[Dict]:
        """
        Retrieves personalized insights and recommendations for a user.

        Args:
            user_id (str): The ID of the user.

        Returns:
            List[Dict]: A list of recommendation dictionaries.
        """
        endpoint = f"{self.base_url}/insights/{user_id}"
        try:
            response = await self.client.get(endpoint)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"Error getting insights: {e.response.status_code} - {e.response.text}")
            return []
        except httpx.RequestError as e:
            print(f"Network error getting insights: {e}")
            return []

# Example usage (for testing purposes, not part of the Flet app itself)
async def test_service():
    service = MentalHealthTrackerService()
    test_user_id = "test_user_123"
    test_username = "tester_account"

    # Try creating a user (if it doesn't exist)
    user = await service.get_user(test_user_id)
    if not user:
        print(f"Creating user {test_username}...")
        user = await service.create_user(test_user_id, test_username)
        if user:
            print(f"User created: {user}")
        else:
            print("Failed to create user.")
            await service.close()
            return
    else:
        print(f"User {test_username} already exists: {user}")

    # Log some moods
    print("Logging moods...")
    await service.log_mood(test_user_id, 4)
    await service.log_mood(test_user_id, 3)
    await service.log_mood(test_user_id, 5)

    # Get mood entries
    moods = await service.get_mood_entries(test_user_id)
    print(f"Recent moods: {moods}")

    # Save journal entries
    print("Saving journal entries...")
    await service.save_journal_entry(test_user_id, "Had a productive day today!")
    await service.save_journal_entry(test_user_id, "Feeling a bit tired, but overall okay.")

    # Get journal entries
    journals = await service.get_journal_entries(test_user_id)
    print(f"Recent journals: {journals}")

    # Get insights
    insights = await service.get_insights(test_user_id)
    print(f"Insights: {insights}")

    await service.close()

# To run the test, uncomment the following lines and run this file directly:
# import asyncio
# if __name__ == "__main__":
#     asyncio.run(test_service())
# -*- coding: utf-8 -*-
"""user data access

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oLxm_vENsiNDSlsa-TjRxlu1s41TQVI8
"""

import httpx
from typing import List, Dict, Optional

# Define the base URL for your FastAPI backend
# Make sure this matches where your FastAPI app is running (e.g., uvicorn main:app --reload)
BASE_API_URL = "http://127.0.0.1:8000"

class MentalHealthTrackerService:
    """
    A service class to handle all data access operations for the Community Mental Health Tracker.
    It communicates with the FastAPI backend.
    """

    def __init__(self, base_url: str = BASE_API_URL):
        """
        Initializes the service with the base URL of the FastAPI backend.
        """
        self.base_url = base_url
        # httpx.AsyncClient should be initialized once and reused for performance
        self.client = httpx.AsyncClient()

    async def close(self):
        """
        Closes the HTTP client session. Should be called when the application exits.
        """
        await self.client.aclose()

    async def _make_request(self, method: str, endpoint: str, json_data: Optional[Dict] = None, params: Optional[Dict] = None) -> Optional[Dict]:
        """
        Helper method to make HTTP requests and handle common errors.
        """
        url = f"{self.base_url}{endpoint}"
        try:
            if method == "POST":
                response = await self.client.post(url, json=json_data)
            elif method == "GET":
                response = await self.client.get(url, params=params)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")

            response.raise_for_status() # Raises an exception for 4xx/5xx responses
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"HTTP error during {method} {url}: {e.response.status_code} - {e.response.text}")
            return None
        except httpx.RequestError as e:
            print(f"Network error during {method} {url}: {e}")
            return None
        except Exception as e:
            print(f"An unexpected error occurred during {method} {url}: {e}")
            return None

    async def create_user(self, user_id: str, username: str) -> Optional[Dict]:
        """
        Creates a new user in the backend.
        """
        return await self._make_request("POST", "/users/", json_data={"id": user_id, "username": username})

    async def get_user(self, user_id: str) -> Optional[Dict]:
        """
        Retrieves user details from the backend.
        """
        return await self._make_request("GET", f"/users/{user_id}")

    async def log_mood(self, user_id: str, mood_score: int) -> Optional[Dict]:
        """
        Logs a new mood entry for a specific user.
        """
        return await self._make_request("POST", "/mood_entries/", json_data={"user_id": user_id, "mood_score": mood_score})

    async def get_mood_entries(self, user_id: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """
        Retrieves recent mood entries for a specific user.
        """
        params = {"limit": limit, "offset": offset}
        result = await self._make_request("GET", f"/mood_entries/{user_id}", params=params)
        return result if result is not None else []

    async def save_journal_entry(self, user_id: str, entry_text: str) -> Optional[Dict]:
        """
        Saves a new journal entry for a specific user.
        """
        return await self._make_request("POST", "/journal_entries/", json_data={"user_id": user_id, "entry_text": entry_text})

    async def get_journal_entries(self, user_id: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        """
        Retrieves recent journal entries for a specific user.
        """
        params = {"limit": limit, "offset": offset}
        result = await self._make_request("GET", f"/journal_entries/{user_id}", params=params)
        return result if result is not None else []

    async def get_insights(self, user_id: str) -> List[Dict]:
        """
        Retrieves personalized insights and recommendations for a user.
        """
        result = await self._make_request("GET", f"/insights/{user_id}")
        return result if result is not None else []

# Example usage (for testing purposes, not part of the Flet app itself)
# To run the test, uncomment the following lines and run this file directly:
# import asyncio
# async def test_service_run():
#     service = MentalHealthTrackerService()
#     test_user_id = "test_user_123"
#     test_username = "tester_account"

#     print("--- Testing User Creation/Retrieval ---")
#     user = await service.get_user(test_user_id)
#     if not user:
#         print(f"Creating user {test_username}...")
#         user = await service.create_user(test_user_id, test_username)
#         if user:
#             print(f"User created: {user}")
#         else:
#             print("Failed to create user.")
#             await service.close()
#             return
#     else:
#         print(f"User {test_username} already exists: {user}")

#     print("\n--- Testing Mood Logging ---")
#     logged_mood = await service.log_mood(test_user_id, 4)
#     print(f"Logged mood: {logged_mood}")
#     await service.log_mood(test_user_id, 3)
#     await service.log_mood(test_user_id, 5)

#     print("\n--- Testing Get Mood Entries ---")
#     moods = await service.get_mood_entries(test_user_id)
#     print(f"Recent moods ({len(moods)}): {moods}")

#     print("\n--- Testing Journal Entry Saving ---")
#     saved_journal = await service.save_journal_entry(test_user_id, "Had a productive day today!")
#     print(f"Saved journal entry: {saved_journal}")
#     await service.save_journal_entry(test_user_id, "Feeling a bit tired, but overall okay.")

#     print("\n--- Testing Get Journal Entries ---")
#     journals = await service.get_journal_entries(test_user_id)
#     print(f"Recent journals ({len(journals)}): {journals}")

#     print("\n--- Testing Get Insights ---")
#     insights = await service.get_insights(test_user_id)
#     print(f"Insights ({len(insights)}): {insights}")

#     await service.close()
#     print("\nService test completed and client closed.")

# if __name__ == "__main__":
#     asyncio.run(test_service_run())
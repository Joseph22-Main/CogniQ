# -*- coding: utf-8 -*-
"""Combined Flet UI + FastAPI Backend

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sXTlXv4YCYiw21xm8ZIbhpMasgNNCg5l
"""

import flet as ft
import datetime
import asyncio
import threading
import time
import sqlite3

# --- FastAPI Imports ---
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional

# --- 1. FastAPI Application Setup (User Logic / API) ---
# This is the same FastAPI code from your 'mental_health_tracker_logic'
app = FastAPI(
    title="Community Mental Health Tracker API",
    description="Backend API for managing user mood logs, journal entries, and insights.",
    version="1.0.0"
)

# --- 2. Database Setup (SQLite) ---
DATABASE_URL = "./mental_health_tracker.db"

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    conn = sqlite3.connect(DATABASE_URL)
    conn.row_factory = sqlite3.Row # This allows accessing columns by name
    return conn

def create_tables():
    """Creates necessary tables in the SQLite database if they don't exist."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id TEXT PRIMARY KEY,
            username TEXT UNIQUE NOT NULL,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        );
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS mood_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT NOT NULL,
            mood_score INTEGER NOT NULL, -- 1 to 5
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        );
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS journal_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT NOT NULL,
            entry_text TEXT NOT NULL,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        );
    """)
    conn.commit()
    conn.close()

# Ensure tables are created when the application starts
# This will be called by the FastAPI server when it starts
@app.on_event("startup")
async def startup_event():
    """Event handler for application startup to create database tables."""
    create_tables()
    print("FastAPI: Database tables checked/created.")

# --- 3. Pydantic Models (Data Structures) ---
class UserBase(BaseModel):
    username: str

class UserCreate(UserBase):
    id: str

class User(UserCreate):
    created_at: str

    class Config:
        from_attributes = True

class MoodEntryBase(BaseModel):
    mood_score: int

class MoodEntryCreate(MoodEntryBase):
    user_id: str

class MoodEntry(MoodEntryCreate):
    id: int
    timestamp: str

    class Config:
        from_attributes = True

class JournalEntryBase(BaseModel):
    entry_text: str

class JournalEntryCreate(JournalEntryBase):
    user_id: str

class JournalEntry(JournalEntryCreate):
    id: int
    timestamp: str

    class Config:
        from_attributes = True

class Recommendation(BaseModel):
    type: str
    content: str
    source: Optional[str] = None

# --- 4. API Endpoints (Controller Logic) ---
@app.post("/users/", response_model=User)
async def create_user(user: UserCreate):
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO users (id, username) VALUES (?, ?)",
                       (user.id, user.username))
        conn.commit()
        cursor.execute("SELECT * FROM users WHERE id = ?", (user.id,))
        new_user_data = cursor.fetchone()
        if new_user_data:
            return User(**new_user_data)
        else:
            raise HTTPException(status_code=500, detail="Failed to retrieve created user.")
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username or User ID already exists")
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: str):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
    user_data = cursor.fetchone()
    conn.close()
    if user_data is None:
        raise HTTPException(status_code=404, detail="User not found")
    return User(**user_data)

@app.post("/mood_entries/", response_model=MoodEntry)
async def create_mood_entry(mood_entry: MoodEntryCreate):
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO mood_entries (user_id, mood_score) VALUES (?, ?)",
                       (mood_entry.user_id, mood_entry.mood_score))
        conn.commit()
        cursor.execute("SELECT * FROM mood_entries WHERE id = ?", (cursor.lastrowid,))
        new_entry_data = cursor.fetchone()
        if new_entry_data:
            return MoodEntry(**new_entry_data)
        else:
            raise HTTPException(status_code=500, detail="Failed to retrieve created mood entry.")
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/mood_entries/{user_id}", response_model=List[MoodEntry])
async def get_mood_entries(user_id: str, limit: int = 10, offset: int = 0):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM mood_entries WHERE user_id = ? ORDER BY timestamp DESC LIMIT ? OFFSET ?",
        (user_id, limit, offset)
    )
    entries_data = cursor.fetchall()
    conn.close()
    return [MoodEntry(**entry) for entry in entries_data]

@app.post("/journal_entries/", response_model=JournalEntry)
async def create_journal_entry(journal_entry: JournalEntryCreate):
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO journal_entries (user_id, entry_text) VALUES (?, ?)",
                       (journal_entry.user_id, journal_entry.entry_text))
        conn.commit()
        cursor.execute("SELECT * FROM journal_entries WHERE id = ?", (cursor.lastrowid,))
        new_entry_data = cursor.fetchone()
        if new_entry_data:
            return JournalEntry(**new_entry_data)
        else:
            raise HTTPException(status_code=500, detail="Failed to retrieve created journal entry.")
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/journal_entries/{user_id}", response_model=List[JournalEntry])
async def get_journal_entries(user_id: str, limit: int = 10, offset: int = 0):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM journal_entries WHERE user_id = ? ORDER BY timestamp DESC LIMIT ? OFFSET ?",
        (user_id, limit, offset)
    )
    entries_data = cursor.fetchall()
    conn.close()
    return [JournalEntry(**entry) for entry in entries_data]

@app.get("/insights/{user_id}", response_model=List[Recommendation])
async def get_user_insights(user_id: str):
    # Placeholder for your actual insights logic, Matplotlib, and external API integrations
    recommendations = [
        Recommendation(
            type="mindfulness",
            content="Based on your recent mood patterns, consider practicing mindfulness exercises for 15 minutes daily.",
            source="Internal Algorithm"
        ),
        Recommendation(
            type="journaling_tip",
            content="Your journaling frequency is consistent, which is great for self-reflection! Try focusing on gratitude entries.",
            source="Internal Algorithm"
        ),
        Recommendation(
            type="resource",
            content="Explore local support resources: Visit [Local Mental Health Org Website] for community programs.",
            source="Local Org API"
        )
    ]
    return recommendations

# --- User Data Access Module (The Bridge) ---
# This is the same MentalHealthTrackerService from your 'user_data_access'
import httpx # Already imported at the top, but keeping here for clarity of origin

BASE_API_URL = "http://127.0.0.1:8000" # Still points to localhost as FastAPI runs in same process

class MentalHealthTrackerService:
    """
    A service class to handle all data access operations for the Community Mental Health Tracker.
    It communicates with the FastAPI backend.
    """

    def __init__(self, base_url: str = BASE_API_URL):
        self.base_url = base_url
        self.client = httpx.AsyncClient()

    async def close(self):
        await self.client.aclose()

    async def _make_request(self, method: str, endpoint: str, json_data: Optional[Dict] = None, params: Optional[Dict] = None) -> Optional[Dict]:
        url = f"{self.base_url}{endpoint}"
        try:
            if method == "POST":
                response = await self.client.post(url, json=json_data)
            elif method == "GET":
                response = await self.client.get(url, params=params)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")

            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            print(f"HTTP error during {method} {url}: {e.response.status_code} - {e.response.text}")
            return None
        except httpx.RequestError as e:
            print(f"Network error during {method} {url}: {e}")
            return None
        except Exception as e:
            print(f"An unexpected error occurred during {method} {url}: {e}")
            return None

    async def create_user(self, user_id: str, username: str) -> Optional[Dict]:
        return await self._make_request("POST", "/users/", json_data={"id": user_id, "username": username})

    async def get_user(self, user_id: str) -> Optional[Dict]:
        return await self._make_request("GET", f"/users/{user_id}")

    async def log_mood(self, user_id: str, mood_score: int) -> Optional[Dict]:
        return await self._make_request("POST", "/mood_entries/", json_data={"user_id": user_id, "mood_score": mood_score})

    async def get_mood_entries(self, user_id: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        params = {"limit": limit, "offset": offset}
        result = await self._make_request("GET", f"/mood_entries/{user_id}", params=params)
        return result if result is not None else []

    async def save_journal_entry(self, user_id: str, entry_text: str) -> Optional[Dict]:
        return await self._make_request("POST", "/journal_entries/", json_data={"user_id": user_id, "entry_text": entry_text})

    async def get_journal_entries(self, user_id: str, limit: int = 10, offset: int = 0) -> List[Dict]:
        params = {"limit": limit, "offset": offset}
        result = await self._make_request("GET", f"/journal_entries/{user_id}", params=params)
        return result if result is not None else []

    async def get_insights(self, user_id: str) -> List[Dict]:
        result = await self._make_request("GET", f"/insights/{user_id}")
        return result if result is not None else []


# --- Flet User Interface (UI) ---
# This is the same Flet code from your 'mental_health_tracker_gui'
def main(page: ft.Page):
    """
    Main function to build the Flet application GUI for the Community Mental Health Tracker.
    """
    page.title = "Community Mental Health Tracker"
    page.vertical_alignment = ft.CrossAxisAlignment.START
    page.horizontal_alignment = ft.CrossAxisAlignment.CENTER
    page.window_width = 800
    page.window_height = 600
    page.window_min_width = 700
    page.window_min_height = 500
    page.theme_mode = ft.ThemeMode.LIGHT # Default theme mode

    # Initialize the data access service
    service = MentalHealthTrackerService()

    # Placeholder for user ID (would come from authentication in a real app)
    user_id = "demo_user_123"
    username = "DemoUser"

    # --- UI Components ---
    mood_slider = ft.Slider(
        min=1, max=5, divisions=4, label="{value}", value=3, width=300,
    )
    mood_feedback_text = ft.Text("Rate your mood (1: Very Low, 5: Very High)", size=16)
    mood_log_display = ft.Column([], scroll=ft.ScrollMode.ADAPTIVE, expand=True)

    async def log_mood(e):
        current_mood = int(mood_slider.value)
        new_entry = await service.log_mood(user_id, current_mood)

        if new_entry:
            timestamp = new_entry.get("timestamp", datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            mood_log_display.controls.insert(
                0,
                ft.Text(f"[{timestamp}] Mood: {current_mood} {'⭐' * current_mood}", size=14)
            )
            page.snack_bar = ft.SnackBar(ft.Text("Mood logged successfully!"), open=True)
        else:
            page.snack_bar = ft.SnackBar(ft.Text("Failed to log mood. Please check backend connection."), open=True)
        page.update()

    async def load_mood_entries():
        mood_log_display.controls.clear()
        entries = await service.get_mood_entries(user_id)
        if entries:
            for entry in entries:
                mood_log_display.controls.append(
                    ft.Text(f"[{entry['timestamp']}] Mood: {entry['mood_score']} {'⭐' * entry['mood_score']}", size=14)
                )
        else:
            mood_log_display.controls.append(ft.Text("No mood entries yet.", size=14, color=ft.colors.GREY_500))
        page.update()

    mood_tracker_content = ft.Column(
        [
            ft.Text("Track Your Mood", size=24, weight=ft.FontWeight.BOLD),
            ft.Divider(),
            mood_feedback_text,
            mood_slider,
            ft.ElevatedButton("Log Mood", on_click=log_mood, icon=ft.icons.EMOJI_EMOTIONS),
            ft.Divider(),
            ft.Text("Recent Mood Logs:", size=18, weight=ft.FontWeight.BOLD),
            ft.Container(
                content=mood_log_display,
                height=200,
                width=page.window_width * 0.8,
                padding=10,
                border=ft.border.all(1, ft.colors.GREY_300),
                border_radius=ft.border_radius.all(10),
                expand=True
            )
        ],
        horizontal_alignment=ft.CrossAxisAlignment.CENTER,
        spacing=20,
        expand=True
    )

    journal_entry_field = ft.TextField(
        label="Write your journal entry here...",
        multiline=True, min_lines=5, max_lines=10, expand=True, border_radius=ft.border_radius.all(10)
    )
    journal_log_display = ft.Column([], scroll=ft.ScrollMode.ADAPTIVE, expand=True)

    async def save_journal_entry(e):
        entry_text = journal_entry_field.value.strip()
        if entry_text:
            new_entry = await service.save_journal_entry(user_id, entry_text)

            if new_entry:
                timestamp = new_entry.get("timestamp", datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
                journal_log_display.controls.insert(
                    0,
                    ft.Card(
                        content=ft.Container(
                            content=ft.Column(
                                [
                                    ft.Text(f"[{timestamp}]", size=12, color=ft.colors.GREY_600),
                                    ft.Text(entry_text, size=14, selectable=True),
                                ],
                                spacing=5
                            ),
                            padding=10,
                        ),
                        elevation=2,
                        margin=ft.margin.only(bottom=10)
                    )
                )
                journal_entry_field.value = ""
                page.snack_bar = ft.SnackBar(ft.Text("Journal entry saved successfully!"), open=True)
            else:
                page.snack_bar = ft.SnackBar(ft.Text("Failed to save journal entry. Check backend."), open=True)
        else:
            page.snack_bar = ft.SnackBar(ft.Text("Journal entry cannot be empty!"), open=True)
        page.update()

    async def load_journal_entries():
        journal_log_display.controls.clear()
        entries = await service.get_journal_entries(user_id)
        if entries:
            for entry in entries:
                journal_log_display.controls.append(
                    ft.Card(
                        content=ft.Container(
                            content=ft.Column(
                                [
                                    ft.Text(f"[{entry['timestamp']}]", size=12, color=ft.colors.GREY_600),
                                    ft.Text(entry['entry_text'], size=14, selectable=True),
                                ],
                                spacing=5
                            ),
                            padding=10,
                        ),
                        elevation=2,
                        margin=ft.margin.only(bottom=10)
                    )
                )
        else:
            journal_log_display.controls.append(ft.Text("No journal entries yet.", size=14, color=ft.colors.GREY_500))
        page.update()

    journaling_content = ft.Column(
        [
            ft.Text("Your Daily Journal", size=24, weight=ft.FontWeight.BOLD),
            ft.Divider(),
            journal_entry_field,
            ft.ElevatedButton("Save Entry", on_click=save_journal_entry, icon=ft.icons.BOOKMARK_ADD),
            ft.Divider(),
            ft.Text("Recent Journal Entries:", size=18, weight=ft.FontWeight.BOLD),
            ft.Container(
                content=journal_log_display,
                height=250,
                width=page.window_width * 0.8,
                padding=10,
                border=ft.border.all(1, ft.colors.GREY_300),
                border_radius=ft.border_radius.all(10),
                expand=True
            )
        ],
        horizontal_alignment=ft.CrossAxisAlignment.CENTER,
        spacing=20,
        expand=True
    )

    insights_recommendations_display = ft.Column([], expand=True)

    async def load_insights():
        insights_recommendations_display.controls.clear()
        recommendations = await service.get_insights(user_id)

        if recommendations:
            for rec in recommendations:
                insights_recommendations_display.controls.append(
                    ft.Card(
                        content=ft.Container(
                            content=ft.Column(
                                [
                                    ft.Text(f"Type: {rec.get('type', 'N/A')}", size=12, color=ft.colors.BLUE_GREY_600),
                                    ft.Text(rec.get('content', 'No content'), size=14, selectable=True),
                                    ft.Text(f"Source: {rec.get('source', 'Internal')}", size=10, color=ft.colors.GREY_500)
                                ],
                                spacing=5
                            ),
                            padding=15,
                        ),
                        elevation=2,
                        margin=ft.margin.only(bottom=10)
                    )
                )
        else:
            insights_recommendations_display.controls.append(ft.Text("No insights available yet.", size=14, color=ft.colors.GREY_500))
        page.update()

    insights_content = ft.Column(
        [
            ft.Text("Your Wellness Insights", size=24, weight=ft.FontWeight.BOLD),
            ft.Divider(),
            ft.Text("Mood Trends Over Time (Matplotlib Integration Here)", size=18),
            ft.Container(
                content=ft.Image(
                    src="https://placehold.co/400x200/cccccc/333333?text=Mood+Trend+Graph",
                    width=400,
                    height=200,
                    fit=ft.ImageFit.CONTAIN
                ),
                alignment=ft.alignment.center,
                margin=ft.margin.symmetric(vertical=10)
            ),
            ft.Text("Journaling Frequency (Matplotlib Integration Here)", size=18),
            ft.Container(
                content=ft.Image(
                    src="https://placehold.co/400x150/cccccc/333333?text=Journal+Frequency+Graph",
                    width=400,
                    height=150,
                    fit=ft.ImageFit.CONTAIN
                ),
                alignment=ft.alignment.center,
                margin=ft.margin.symmetric(vertical=10)
            ),
            ft.Text("Personalized Coping Strategies & Recommendations:", size=18, weight=ft.FontWeight.BOLD),
            ft.Container(
                content=insights_recommendations_display,
                height=200,
                width=page.window_width * 0.8,
                padding=10,
                border=ft.border.all(1, ft.colors.GREY_300),
                border_radius=ft.border_radius.all(10),
                expand=True
            )
        ],
        horizontal_alignment=ft.CrossAxisAlignment.CENTER,
        spacing=20,
        scroll=ft.ScrollMode.ADAPTive,
        expand=True
    )

    async def change_tab(e):
        selected_index = e.control.selected_index
        if selected_index == 0:
            content_area.content = mood_tracker_content
            await load_mood_entries()
        elif selected_index == 1:
            content_area.content = journaling_content
            await load_journal_entries()
        elif selected_index == 2:
            content_area.content = insights_content
            await load_insights()
        page.update()

    content_area = ft.Container(
        content=mood_tracker_content,
        expand=True,
        alignment=ft.alignment.top_center,
        padding=20
    )

    async def initialize_app():
        user = await service.get_user(user_id)
        if not user:
            print(f"Flet: User '{user_id}' not found, creating new user...")
            new_user = await service.create_user(user_id, username)
            if new_user:
                print(f"Flet: User '{username}' created successfully.")
            else:
                print(f"Flet: Failed to create user '{username}'. App may not function correctly.")
                page.snack_bar = ft.SnackBar(ft.Text("Failed to initialize user. Check backend."), open=True)
                page.update()
        else:
            print(f"Flet: User '{username}' ({user_id}) already exists.")

        await load_mood_entries() # Load initial data for the default tab
        page.update()

    async def on_page_close(e):
        await service.close()
        print("Flet: HTTP client session closed.")

    page.on_disconnect = on_page_close
    page.on_close = on_page_close

    page.add(
        ft.Column(
            [
                ft.AppBar(
                    title=ft.Text("Mental Health Tracker", weight=ft.FontWeight.BOLD),
                    center_title=True,
                    bgcolor=ft.colors.BLUE_GREY_700,
                    color=ft.colors.WHITE,
                    actions=[
                        ft.IconButton(ft.icons.SETTINGS, tooltip="Settings"),
                        ft.IconButton(ft.icons.HELP_OUTLINE, tooltip="Help"),
                    ],
                ),
                ft.Container(
                    content=ft.Column(
                        [
                            ft.Text(f"Welcome, {username}!", size=16, weight=ft.FontWeight.W_500),
                            ft.NavigationBar(
                                selected_index=0,
                                on_change=change_tab,
                                destinations=[
                                    ft.NavigationDestination(icon=ft.icons.EMOJI_EMOTIONS, label="Mood Tracker"),
                                    ft.NavigationDestination(icon=ft.icons.BOOK, label="Journaling"),
                                    ft.NavigationDestination(icon=ft.icons.INSIGHTS, label="Insights"),
                                ],
                                bgcolor=ft.colors.BLUE_GREY_100,
                                elevation=5,
                            ),
                        ],
                        horizontal_alignment=ft.CrossAxisAlignment.CENTER,
                        spacing=15
                    ),
                    padding=ft.padding.only(top=10, bottom=10),
                    width=page.window_width,
                    alignment=ft.alignment.center
                ),
                content_area,
            ],
            expand=True,
            horizontal_alignment=ft.CrossAxisAlignment.CENTER,
            spacing=0
        )
    )
    page.run_async(initialize_app())

# --- Main Entry Point to Run Both FastAPI and Flet ---
import uvicorn # Import uvicorn here

def run_fastapi_server():
    """Function to run the FastAPI application."""
    # Use log_level="error" or "critical" to reduce FastAPI/Uvicorn console output
    uvicorn.run(app, host="127.0.0.1", port=8000, log_level="info")

if __name__ == "__main__":
    # Start FastAPI server in a separate thread
    fastapi_thread = threading.Thread(target=run_fastapi_server)
    fastapi_thread.daemon = True # Allow the main program (Flet) to exit even if this thread is running
    fastapi_thread.start()

    # Give the FastAPI server a moment to start up before Flet tries to connect
    # Adjust this delay if you encounter connection errors on startup
    time.sleep(3)
    print("Flet: Attempting to start Flet application...")

    # Run the Flet application
    ft.app(target=main)
# -*- coding: utf-8 -*-
"""user logic

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MTEKHADFUVPa8R6mmV9T36GblzdmgV6W
"""

import sqlite3
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import datetime

# --- 1. FastAPI Application Setup ---
app = FastAPI(
    title="Community Mental Health Tracker API",
    description="Backend API for managing user mood logs, journal entries, and insights.",
    version="1.0.0"
)

# --- 2. Database Setup (SQLite) ---
DATABASE_URL = "./mental_health_tracker.db"

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    conn = sqlite3.connect(DATABASE_URL)
    conn.row_factory = sqlite3.Row # This allows accessing columns by name
    return conn

def create_tables():
    """Creates necessary tables in the SQLite database if they don't exist."""
    conn = get_db_connection()
    cursor = conn.cursor()
    # Create users table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id TEXT PRIMARY KEY,
            username TEXT UNIQUE NOT NULL,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        );
    """)
    # Create mood_entries table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS mood_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT NOT NULL,
            mood_score INTEGER NOT NULL, -- 1 to 5
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        );
    """)
    # Create journal_entries table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS journal_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT NOT NULL,
            entry_text TEXT NOT NULL,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
        );
    """)
    conn.commit()
    conn.close()

# Ensure tables are created when the application starts
@app.on_event("startup")
async def startup_event():
    """Event handler for application startup to create database tables."""
    create_tables()
    print("Database tables checked/created.")

# --- 3. Pydantic Models (Data Structures) ---
# These models define the structure of data for requests and responses

class UserBase(BaseModel):
    username: str

class UserCreate(UserBase):
    # User ID is provided by the client for this simple setup
    id: str

class User(UserCreate):
    created_at: str

    class Config:
        # This is for ORM compatibility, useful if you were using SQLAlchemy etc.
        # For raw SQLite, it mainly helps with automatic field mapping from query results.
        from_attributes = True # Changed from orm_mode for Pydantic v2 compatibility

class MoodEntryBase(BaseModel):
    mood_score: int # Expects an integer between 1 and 5

class MoodEntryCreate(MoodEntryBase):
    user_id: str

class MoodEntry(MoodEntryCreate):
    id: int
    timestamp: str

    class Config:
        from_attributes = True

class JournalEntryBase(BaseModel):
    entry_text: str

class JournalEntryCreate(JournalEntryBase):
    user_id: str

class JournalEntry(JournalEntryCreate):
    id: int
    timestamp: str

    class Config:
        from_attributes = True

class Recommendation(BaseModel):
    # Model for recommendations generated by the system
    type: str # e.g., "mindfulness", "resource", "activity"
    content: str # The recommendation text
    source: Optional[str] = None # e.g., "WHO API", "Internal Algorithm"

# --- 4. API Endpoints (Controller Logic) ---

# User Endpoints
@app.post("/users/", response_model=User)
async def create_user(user: UserCreate):
    """Creates a new user in the database."""
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO users (id, username) VALUES (?, ?)",
                       (user.id, user.username))
        conn.commit()
        # Retrieve the newly created user to return, including generated timestamp
        cursor.execute("SELECT * FROM users WHERE id = ?", (user.id,))
        new_user_data = cursor.fetchone()
        if new_user_data:
            return User(**new_user_data)
        else:
            raise HTTPException(status_code=500, detail="Failed to retrieve created user.")
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username or User ID already exists")
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: str):
    """Retrieves a user by their ID."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
    user_data = cursor.fetchone()
    conn.close()
    if user_data is None:
        raise HTTPException(status_code=404, detail="User not found")
    return User(**user_data)

# Mood Entry Endpoints
@app.post("/mood_entries/", response_model=MoodEntry)
async def create_mood_entry(mood_entry: MoodEntryCreate):
    """Logs a new mood entry for a user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO mood_entries (user_id, mood_score) VALUES (?, ?)",
                       (mood_entry.user_id, mood_entry.mood_score))
        conn.commit()
        # Retrieve the newly created entry using lastrowid to get timestamp
        cursor.execute("SELECT * FROM mood_entries WHERE id = ?", (cursor.lastrowid,))
        new_entry_data = cursor.fetchone()
        if new_entry_data:
            return MoodEntry(**new_entry_data)
        else:
            raise HTTPException(status_code=500, detail="Failed to retrieve created mood entry.")
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/mood_entries/{user_id}", response_model=List[MoodEntry])
async def get_mood_entries(user_id: str, limit: int = 10, offset: int = 0):
    """Retrieves recent mood entries for a specific user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM mood_entries WHERE user_id = ? ORDER BY timestamp DESC LIMIT ? OFFSET ?",
        (user_id, limit, offset)
    )
    entries_data = cursor.fetchall()
    conn.close()
    return [MoodEntry(**entry) for entry in entries_data]

# Journal Entry Endpoints
@app.post("/journal_entries/", response_model=JournalEntry)
async def create_journal_entry(journal_entry: JournalEntryCreate):
    """Saves a new journal entry for a user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO journal_entries (user_id, entry_text) VALUES (?, ?)",
                       (journal_entry.user_id, journal_entry.entry_text))
        conn.commit()
        # Retrieve the newly created entry using lastrowid to get timestamp
        cursor.execute("SELECT * FROM journal_entries WHERE id = ?", (cursor.lastrowid,))
        new_entry_data = cursor.fetchone()
        if new_entry_data:
            return JournalEntry(**new_entry_data)
        else:
            raise HTTPException(status_code=500, detail="Failed to retrieve created journal entry.")
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/journal_entries/{user_id}", response_model=List[JournalEntry])
async def get_journal_entries(user_id: str, limit: int = 10, offset: int = 0):
    """Retrieves recent journal entries for a specific user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM journal_entries WHERE user_id = ? ORDER BY timestamp DESC LIMIT ? OFFSET ?",
        (user_id, limit, offset)
    )
    entries_data = cursor.fetchall()
    conn.close()
    return [JournalEntry(**entry) for entry in entries_data]

# --- 5. Insights and Recommendation Logic (Placeholder) ---
@app.get("/insights/{user_id}", response_model=List[Recommendation])
async def get_user_insights(user_id: str):
    """
    Generates and retrieves personalized insights and recommendations for a user.
    This is where your Python Data Structures & Optimization Algorithms would be applied.
    """
    # In a real implementation, you would:
    # 1. Fetch user's mood logs and journal entries from the database.
    #    Example:
    #    conn = get_db_connection()
    #    cursor = conn.cursor()
    #    cursor.execute("SELECT * FROM mood_entries WHERE user_id = ? ORDER BY timestamp DESC", (user_id,))
    #    mood_data = cursor.fetchall()
    #    cursor.execute("SELECT * FROM journal_entries WHERE user_id = ? ORDER BY timestamp DESC", (user_id,))
    #    journal_data = cursor.fetchall()
    #    conn.close()

    # 2. Apply optimization algorithms to analyze patterns (e.g., detect mood swings,
    #    identify triggers from journal text, calculate wellness scores).
    #    For example:
    #    if mood_data and len(mood_data) > 5: # Simple check for enough data
    #        recent_moods = [entry['mood_score'] for entry in mood_data[:5]]
    #        avg_mood = sum(recent_moods) / len(recent_moods)
    #        if avg_mood < 2.5:
    #            recommendations.append(Recommendation(type="activity", content="Consider a short walk outdoors to boost your mood.", source="Internal Algorithm"))
    #        elif avg_mood > 4.0:
    #            recommendations.append(Recommendation(type="reflection", content="It's great to see your high spirits! Reflect on what made today positive.", source="Internal Algorithm"))


    # 3. Integrate with mental health content APIs.
    #    For example, call a WHO API for general wellness tips or local orgs for support.
    #    This would involve making HTTP requests from here to external APIs.
    #    Example (conceptual):
    #    try:
    #        async with httpx.AsyncClient() as client:
    #            who_response = await client.ge
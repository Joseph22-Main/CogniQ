import sqlite3
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Optional
import datetime

# --- 1. FastAPI Application Setup ---
app = FastAPI(
    title="Community Mental Health Tracker API",
    description="Backend API for managing user mood logs, journal entries, and insights.",
    version="1.0.0"
)

# --- 2. Database Setup (SQLite) ---
DATABASE_URL = "./mental_health_tracker.db"

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    conn = sqlite3.connect(DATABASE_URL)
    conn.row_factory = sqlite3.Row # This allows accessing columns by name
    return conn

def create_tables():
    """Creates necessary tables in the SQLite database if they don't exist."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id TEXT PRIMARY KEY,
            username TEXT UNIQUE NOT NULL,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        );
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS mood_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT NOT NULL,
            mood_score INTEGER NOT NULL, -- 1 to 5
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        );
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS journal_entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT NOT NULL,
            entry_text TEXT NOT NULL,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        );
    """)
    conn.commit()
    conn.close()

# Ensure tables are created when the application starts
@app.on_event("startup")
async def startup_event():
    create_tables()
    print("Database tables checked/created.")

# --- 3. Pydantic Models (Data Structures) ---
# These models define the structure of data for requests and responses

class UserBase(BaseModel):
    username: str

class UserCreate(UserBase):
    # For simplicity, we'll use a client-generated ID or a simple username for ID
    # In a real app, this would involve proper authentication (e.g., password hashing)
    id: str # This would typically be generated by the auth system

class User(UserCreate):
    created_at: str

    class Config:
        orm_mode = True # Enable compatibility with ORM (though we're using raw SQLite here)

class MoodEntryBase(BaseModel):
    mood_score: int # Expects an integer between 1 and 5

class MoodEntryCreate(MoodEntryBase):
    user_id: str

class MoodEntry(MoodEntryCreate):
    id: int
    timestamp: str

    class Config:
        orm_mode = True

class JournalEntryBase(BaseModel):
    entry_text: str

class JournalEntryCreate(JournalEntryBase):
    user_id: str

class JournalEntry(JournalEntryCreate):
    id: int
    timestamp: str

    class Config:
        orm_mode = True

class Recommendation(BaseModel):
    # Model for recommendations generated by the system
    type: str # e.g., "mindfulness", "resource", "activity"
    content: str # The recommendation text
    source: Optional[str] = None # e.g., "WHO API", "Internal Algorithm"

# --- 4. API Endpoints (Controller Logic) ---

# User Endpoints
@app.post("/users/", response_model=User)
async def create_user(user: UserCreate):
    """Creates a new user in the database."""
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO users (id, username) VALUES (?, ?)",
                       (user.id, user.username))
        conn.commit()
        # Retrieve the newly created user to return
        cursor.execute("SELECT * FROM users WHERE id = ?", (user.id,))
        new_user = cursor.fetchone()
        return User(**new_user)
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username or User ID already exists")
    finally:
        conn.close()

@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: str):
    """Retrieves a user by their ID."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
    user = cursor.fetchone()
    conn.close()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return User(**user)

# Mood Entry Endpoints
@app.post("/mood_entries/", response_model=MoodEntry)
async def create_mood_entry(mood_entry: MoodEntryCreate):
    """Logs a new mood entry for a user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO mood_entries (user_id, mood_score) VALUES (?, ?)",
                       (mood_entry.user_id, mood_entry.mood_score))
        conn.commit()
        # Retrieve the newly created entry using lastrowid
        cursor.execute("SELECT * FROM mood_entries WHERE id = ?", (cursor.lastrowid,))
        new_entry = cursor.fetchone()
        return MoodEntry(**new_entry)
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/mood_entries/{user_id}", response_model=List[MoodEntry])
async def get_mood_entries(user_id: str, limit: int = 10, offset: int = 0):
    """Retrieves recent mood entries for a specific user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM mood_entries WHERE user_id = ? ORDER BY timestamp DESC LIMIT ? OFFSET ?",
        (user_id, limit, offset)
    )
    entries = cursor.fetchall()
    conn.close()
    return [MoodEntry(**entry) for entry in entries]

# Journal Entry Endpoints
@app.post("/journal_entries/", response_model=JournalEntry)
async def create_journal_entry(journal_entry: JournalEntryCreate):
    """Saves a new journal entry for a user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO journal_entries (user_id, entry_text) VALUES (?, ?)",
                       (journal_entry.user_id, journal_entry.entry_text))
        conn.commit()
        # Retrieve the newly created entry using lastrowid
        cursor.execute("SELECT * FROM journal_entries WHERE id = ?", (cursor.lastrowid,))
        new_entry = cursor.fetchone()
        return JournalEntry(**new_entry)
    except sqlite3.Error as e:
        raise HTTPException(status_code=500, detail=f"Database error: {e}")
    finally:
        conn.close()

@app.get("/journal_entries/{user_id}", response_model=List[JournalEntry])
async def get_journal_entries(user_id: str, limit: int = 10, offset: int = 0):
    """Retrieves recent journal entries for a specific user."""
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT * FROM journal_entries WHERE user_id = ? ORDER BY timestamp DESC LIMIT ? OFFSET ?",
        (user_id, limit, offset)
    )
    entries = cursor.fetchall()
    conn.close()
    return [JournalEntry(**entry) for entry in entries]

# --- 5. Insights and Recommendation Logic (Placeholder) ---
@app.get("/insights/{user_id}", response_model=List[Recommendation])
async def get_user_insights(user_id: str):
    """
    Generates and retrieves personalized insights and recommendations for a user.
    This is where your Python Data Structures & Optimization Algorithms would be applied.
    """
    # In a real implementation:
    # 1. Fetch user's mood logs and journal entries from the database.
    #    mood_data = get_mood_entries_for_analysis(user_id)
    #    journal_data = get_journal_entries_for_analysis(user_id)

    # 2. Apply optimization algorithms to analyze patterns (e.g., detect mood swings,
    #    identify triggers from journal text, calculate wellness scores).
    #    Example:
    #    if recent_mood_is_low(mood_data):
    #        recommendations.append(Recommendation(type="activity", content="Consider a short walk outdoors."))

    # 3. Integrate with mental health content APIs.
    #    For example, call a WHO API for general wellness tips or local orgs for support.
    #    who_tip = fetch_from_who_api()
    #    recommendations.append(Recommendation(type="resource", content=who_tip, source="WHO API"))

    # 4. Generate Matplotlib plots (as images) and store them or serve them.
    #    This part would typically involve generating the plot image and returning its URL or base64 string.
    #    (Not directly handled by this endpoint, but this is where the data for it would be processed)

    # Placeholder recommendations for demonstration
    recommendations = [
        Recommendation(
            type="mindfulness",
            content="Based on your recent mood patterns, consider practicing mindfulness exercises for 15 minutes daily.",
            source="Internal Algorithm"
        ),
        Recommendation(
            type="journaling_tip",
            content="Your journaling frequency is consistent, which is great for self-reflection! Try focusing on gratitude entries.",
            source="Internal Algorithm"
        ),
        Recommendation(
            type="resource",
            content="Explore local support resources: Visit [Local Mental Health Org Website] for community programs.",
            source="Local Org API"
        )
    ]
    return recommendations

# --- How to run this FastAPI application ---
# Save this code as, e.g., `main.py`.
# Install FastAPI and Uvicorn: `pip install fastapi "uvicorn[standard]"`
# Run from your terminal: `uvicorn main:app --reload`
# This will start the server, typically on http://127.0.0.1:8000/docs
# You can then access the interactive API documentation at http://127.0.0.1:8000/docs
